#!/usr/bin/python

# Script to generate RPM spec file based on template
# (c) 2014,2017 Andrey Cherepanov <cas@altlinux.org>

# This program is free software; you can redistribute it and/or modify it
# under the terms of GNU General Public License (GPL) version 3 or later.
from string import Template
import os
import sys
import datetime
import argparse
import subprocess
import re

templates_path = "/usr/share/spectemplates/"

# Get templates path and build list of available templates
t = os.getenv('GENSPEC_TEMPLATES')
if t != None:
	templates_path = t

# Get configured packager
p = subprocess.Popen(['rpm', '--eval', '%{packager}'], stdout=subprocess.PIPE)
out, err = p.communicate()
maintainer = out.rstrip()

m = os.getenv('GENSPEC_PACKAGER')
if m != None:
	maintainer = m

spec_prefixes = {  'python': 'python-module-',
		   'ruby': 'ruby-',
	        }

class Spec:
	"""RPM Spec class"""
	def __init__(self):
		"""Constructor"""
		self.module  = "" 
		self.package = ""
		self.keys = dict( spec_type = "",
				module  = "",
				version = "",
				summary = "",
				license = "",
				url     = "",
				packager    = "",
				description = "",
				stamp       = "",
				lastchange  = "" )
		self.spec = ""

	def apply(self, spectype):
		"""Apply values to spec template"""
		self.keys['packager'] = maintainer
		
		file = open( templates_path + spectype + ".spec", "r" )
		
		# Generate package name
		if spec_prefixes.has_key( spectype ):
			self.package = spec_prefixes[ spectype ] + self.keys['module']
		else:
			self.package = self.keys['module']

		# Generate changelog entry
		self.keys['stamp'] = '* ' \
		  + datetime.datetime.now().strftime("%a %b %d %Y") \
		  + ' ' + self.keys['packager'] \
		  + ' ' + self.keys['version']
		
		# Fill template
		self.spec = file.read()
		file.close()
		self.spec = Template( self.spec ).safe_substitute( self.keys )
		
	def deploy(self):
		"""Generate directory with spec and gear rules"""
		self.apply( self.keys['spec_type'] )
		
		# Create directory
		if os.path.basename(os.getcwd()) != self.package:
			os.mkdir( self.package )
			os.chdir( self.package )
		
		# Create gear rules
		os.mkdir( '.gear' )
		if self.package != self.keys['module']:
			gear_rules = "tar: . name=" + self.keys['module'] + "-@version@ base=" + self.keys['module'] + "-@version@"
		else:
			gear_rules = "tar: ."
		f = open( '.gear/rules', 'w' )
		f.write( gear_rules )
		f.close()
		
		# Save spec file
		f = open( self.package + '.spec', 'w' )
		f.write( self.spec )
		f.close()
		
# ======================================================================================================
spec = Spec()
		
# Read command-line parameters
parser = argparse.ArgumentParser(
    # version='1.0.0', 
    description='Script to generate RPM spec file based on template',
    formatter_class=argparse.RawDescriptionHelpFormatter,
    epilog=
"""
Supported environment variables:
GENSPEC_TEMPLATES	Path to spec templates (default /usr/share/spectemplates/)
GENSPEC_PACKAGER	Packager name (default from `rpm --eval '%{packager}'`)
""")

parser.add_argument('-n', action='store', dest='module', help='Package or module name')
parser.add_argument('-t', action='store', dest='spec_type', help='Package type')
parser.add_argument('-v', action='store', dest='version', help='Package version')
parser.add_argument('-s', action='store', dest='summary', help='Package summary')
parser.add_argument('-l', action='store', dest='license', help='Package license')
parser.add_argument('-u', action='store', dest='url', help='Package URL')
parser.add_argument('-d', action='store', dest='description', help='Package description')
parser.add_argument('-c', action='store', dest='lastchange', help='Package changes')

# Fill values...
args = parser.parse_args()

def get_available_types():
    available_types = []
    try:
        file_names = os.listdir(templates_path)
        available_types = [x.replace('.spec','') for x in file_names if x.endswith('.spec')]
    except:
        print('Directory ' + templates_path + ' does not exist or does not contain any spec templates')

    return (' (' + ','.join(list(sorted(list(available_types)))) + ')')


def input_with_check(prompt):
    res = raw_input(prompt)
    # skip empty string and string containing only white spaces
    while (re.match('^\s*$', res)):
        print("Parameter should not be empty")
        res = raw_input(prompt)
    return res

read_dict = {}

if len(sys.argv) < 2:
    # Go to interactive mode
    read_dict['module']      = input_with_check('Package or module name: ')
    read_dict['spec_type']   = input_with_check('Package type' + get_available_types() + ': ')
    read_dict['version']     = input_with_check('Package version: ')
    read_dict['summary']     = input_with_check('Package summary: ')
    read_dict['license']     = input_with_check('Package license: ')
    read_dict['url']         = input_with_check('Package URL: ')
    read_dict['description'] = input_with_check('Package description: ')
    read_dict['lastchange']  = input_with_check('Package changelog: ')
    
    spec.keys = read_dict
else:
    spec.keys = args.__dict__

# Prepare place
spec.deploy()
